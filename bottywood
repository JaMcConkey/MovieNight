import os
import requests
import discord
import database
from discord.ext import commands, tasks
from discord.ui import View, Button

from dotenv import load_dotenv

load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
TMDB_TOKEN = os.getenv('TMDB_TOKEN')

bot_prefix = '!'

# #Intents
intents = discord.Intents.default()
intents.message_content = True
intents.reactions = True
intents.members = True

bot = commands.Bot(command_prefix=bot_prefix, intents=intents)

server_data = {}

#Dic fields 
#TODO Move to database
channel_ID = 1281240739249913947 #hardset for 1 server, will change later
cur_movie = None
cur_message = None #Message in this case is tracking the post/embed
cur_host = None


def populate_server_data():
    for guild in bot.guilds:
        server_data[guild.id] = {"cur_message": None,"cur_movie": None,"cur_host": None,"channel_ID": None}

@bot.command()
async def sync(ctx):
    # Sync commands with Discord
    await bot.sync_commands()

@bot.slash_command()
async def set_host(interaction: discord.Interaction, user: discord.Member):
    guild_id = str(interaction.guild_id) 

    # Double check user is in guild
    #TODO Should we make sure they are also a picker? Also add a confirm to swap hosts
    if user not in interaction.guild.members:
        await interaction.response.send_message("User is not in the guild.", ephemeral=True)
        return
    else:
        await update_message()
        await interaction.response.send_message("Udsfdsild.", ephemeral=True)

@bot.event
async def on_ready():
    populate_server_data()
    await create_message()
# Get's movies where the user can cycle through to pick. 
def get_movie_details(movie_name):
    url = f"https://api.themoviedb.org/3/search/movie?api_key={TMDB_TOKEN}&query={movie_name}"
    response = requests.get(url)
    
    if response.status_code == 200:
        data = response.json()
        if data['results']:
            # Return all movie results
            return data['results']
    return None

async def create_message():
    global cur_message
    channel = bot.get_channel(channel_ID) #TODO Stop hard setting here
    if isinstance(channel, discord.TextChannel):
        embed = discord.Embed(
            title='Host Goes Here',
            color=discord.Color.green()
        )
        cur_message = await channel.send(embed=embed)
    else:
        print("Not proper channel")

#Updates the bots primary display message
async def update_message():
    global cur_message
    if cur_message:
        new_embed = discord.Embed(
            title='Updated title',
            description='Updated description',
            color=discord.Color.blue()
        )
        new_embed.add_field(name="Next Movie Picker", value='USERNAME')
        await cur_message.edit(embed=new_embed)  # Edit the existing message
    else:
        print("NO MESSAGE TO UPDATE???")

def set_picked_movie(user,movie):
    user_id = str(user.id)
    guild_id = str(user.guild.id)
    database.set_user_picked_movie(user_id,movie,guild_id,movie)


# View class for movie interaction with pagination
class MovieView(View):
    def __init__(self, movies, user):
        super().__init__(timeout=60) 
        self.movies = movies
        self.index = 0  
        self.user = user 

    async def update_embed(self, interaction):
        """Update the embed with the current movie details."""
        movie = self.movies[self.index]
        embed = discord.Embed(
            title=movie['title'],
            description=movie['overview'],
            color=discord.Color.blue()
        )
        embed.add_field(name="Release Date", value=movie['release_date'], inline=True)
        embed.add_field(name="Rating", value=movie['vote_average'], inline=True)
        
        if movie['poster_path']:
            poster_url = f"https://image.tmdb.org/t/p/w500{movie['poster_path']}"
            embed.set_image(url=poster_url)

        # Update the interaction with the new embed
        await interaction.response.edit_message(embed=embed, view=self)

    @discord.ui.button(label="Previous", style=discord.ButtonStyle.secondary)
    async def previous_movie(self, button: Button, interaction: discord.Interaction):
        """Go to the previous movie."""
        if interaction.user == self.user:
            self.index = (self.index - 1) % len(self.movies)  # % to ensure wrap around
            await self.update_embed(interaction)


    @discord.ui.button(label="Next", style=discord.ButtonStyle.primary)
    async def next_movie(self, button: Button, interaction: discord.Interaction):
        """Go to the next movie."""
        if interaction.user == self.user:
            self.index = (self.index + 1) % len(self.movies)  
            await self.update_embed(interaction)


    @discord.ui.button(label="Pick", style=discord.ButtonStyle.success)
    async def register_movie(self, button: Button, interaction: discord.Interaction):
        """Picks the current movie."""
        if interaction.user == self.user:
            movie = self.movies[self.index]
            set_picked_movie(interaction.user,movie['title'])
            await interaction.response.send_message(f"Selected '{movie['title']}' ", ephemeral=True)


###COMMANDS###
# Send a list of movies to choose from
@bot.slash_command()
async def pick_movie(ctx, *, movie_name):
    movies = get_movie_details(movie_name)
    
    if movies:
        movie = movies[0] 
        embed = discord.Embed(
            title=movie['title'],
            description=movie['overview'],
            color=discord.Color.green()
        )
        embed.add_field(name="Release Date", value=movie['release_date'], inline=True)
        embed.add_field(name="Rating", value=movie['vote_average'], inline=True)
        
        if movie['poster_path']:
            poster_url = f"https://image.tmdb.org/t/p/w500{movie['poster_path']}"
            embed.set_image(url=poster_url)
        
        # Send it with the author (user), and ephemeral
        await ctx.respond(embed=embed, view=MovieView(movies, ctx.author), ephemeral=True)
    else:
        await ctx.respond("Movie not found. Please try again.", ephemeral=True)
@bot.slash_command()
async def join_movienight(ctx):
    guild_id = str(ctx.guild.id)  # Get the current server (guild) ID
    user = ctx.author.id
    database.add_new_picker(user, guild_id)
    #TODO add message for failed to add
    await ctx.respond(f"Added new picker {user} to server {ctx.guild.name}")

@bot.slash_command()
async def i_hate_my_friends():
    ###This function will set you to inactive
    pass
@bot.slash_command()
async def join_the_friends():
    ###This function will set you to active
    pass

@bot.slash_command()
async def lock_it_in():
    ###This is to set lock in the current movie - Only reason function is so you /watched to commit it and reveal the movie
    pass
@bot.slash_command()
async def watched():
    ### Commits the locked in movie to watched
    pass

########################TO REMOVE COMMANDS- FOR DEBUGGING################
@bot.slash_command()
async def test_command(ctx,*,username):
    print(username)
    if database.check_user_exists(username, str(ctx.guild.id)):
        await ctx.respond("USER EXISTS")
    else:
        await ctx.respond("DOES NOT EXIST")
    

bot.run(TOKEN)


