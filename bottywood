import os
import requests
import discord
import database
from discord.ext import commands, tasks
from discord.ui import View, Button

from dotenv import load_dotenv

load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
TMDB_TOKEN = os.getenv('TMDB_TOKEN')

bot_prefix = '!'

# #Intents
intents = discord.Intents.default()
intents.message_content = True
intents.reactions = True
intents.members = True

bot = commands.Bot(command_prefix=bot_prefix, intents=intents)


#TODO Create a cog for the commands if i'm ambitious
#TODO - BIG MAYBE - SWAP everything to movie ID from MovieDB?
@bot.event
async def on_ready():
    pass
   # await create_message()

def session_check():
    async def predicate(ctx):
        guild_id = str(ctx.guild.id)
        if database.session_exists(guild_id):
            return True
        else:
            await ctx.respond("No active session. Use the command !setup_movienight_bot_here .", ephemeral=True)
            return False
    return commands.check(predicate) 



@bot.command()
async def sync(ctx):
    # Sync commands with Discord
    await bot.sync_commands()

@bot.command()
async def setup_movienight_bot_here(ctx):
    guild_id = str(ctx.guild.id)
    if database.session_exists(guild_id):
        await ctx.respond("A session already exists")
        return
    #If no session, create one with whoever called the command
    guild_id = str(ctx.guild.id)
    host_id = str(ctx.author.id)
    channel_id = str(ctx.channel.id)
    message = await ctx.send("Creating initial message here - This should dynamically update")
    message_id = str(message.id)
    database.update_or_create_session_data(guild_id,host_id,channel_id,message_id)
@bot.command()
async def clear_session(ctx):
    if database.session_exists(str(ctx.guild.id)):
        database.remove_session_data(str(ctx.guild.id))

@bot.slash_command()
@session_check()
async def set_host(interaction: discord.Interaction, user: discord.Member):
    guild_id = str(interaction.guild_id) 

    # Double check user is in guild
    #TODO Should we make sure they are also a picker? Also add a confirm to swap hosts
    if user not in interaction.guild.members:
        await interaction.response.send_message("User is not in the guild.", ephemeral=True)
        return
    else:
        await update_message()
        await interaction.response.send_message("Udsfdsild.", ephemeral=True)

# Get's movies where the user can cycle through to pick. 
def get_movie_details(movie_name):
    url = f"https://api.themoviedb.org/3/search/movie?api_key={TMDB_TOKEN}&query={movie_name}"
    response = requests.get(url)
    
    if response.status_code == 200:
        data = response.json()
        if data['results']:
            # Return all movie results
            return data['results']
    return None

async def get_user_name_from_id(user_id, guild_id):
    guild = bot.get_guild(int(guild_id))
    if guild:
        member = guild.get_member(int(user_id))
        if member:
            print("HAVE MEMBER")
            return member.display_name 
        member = await guild.fetch_member(user_id)
        return member.display_name 
    print("NO GUILD?")
    return None
#Updates the bots primary display message
async def update_message(guild_id):
    if not database.session_exists(guild_id):
        print("Tried to call update_message without a session - Why")
        return
    host_id, channel_id, message_id = database.get_session_data(guild_id)
    channel = bot.get_channel(channel_id) or await bot.fetch_channel(channel_id)
    if channel == None:
        print("NO CHannel??")
    message = await channel.fetch_message(message_id)
    if message:
        host_name = bot.get_user(host_id)
        new_embed = discord.Embed(
            title= f'Your host is:  {host_name}',
            description='',
            color=discord.Color.blue()
        )
#Get the last to pick, if they haven't picked there's a different message
        cur_pick_user_id,picked_movie = database.get_last_active_picker(guild_id)
        if picked_movie:
            val = f"The movie will be ___ {picked_movie} - Picked by {await get_user_name_from_id(cur_pick_user_id,guild_id)}.___ - WILL HIDE THIS LATER UNTIL THE HOST LOCKS IT IN"
        else:
            val = f"FUCKO {await get_user_name_from_id(cur_pick_user_id,guild_id)} HASN'T PICKED YET"
        
        new_embed.add_field(
            name="__The next movie will be__",
            value=val,
            inline=False
        )
        new_embed.add_field(name="User", value="Fetching...", inline=True)
        new_embed.add_field(name="Last Pick", value="Fetching...", inline=True)
        new_embed.add_field(name="Status", value="Fetching...", inline=True)
        user_field = ""
        pick_field = ""
        status_field = ""
        for data in database.get_pickers(10,guild_id):
            user_id, last_pick_date, current_movie,status = data
            #Note: this returns status as a string, so we'll check for that
            #1 = user, 2 = Last Pick, 3 = Status   FOR EMBEDS
            if status != "True":
                continue
            user_field += f"{await get_user_name_from_id(user_id,guild_id)}\n"
            pick_field += f"{last_pick_date}\n"
            if current_movie != None or "":
                status_field += f"{current_movie}\n"
            else:
                status_field += "FUCKO HASN'T PICKED \n" 
                
        new_embed.set_field_at(
            1,
            name="User",
            value=user_field,
        )
        new_embed.set_field_at(
            2,
            name="Last Pick",
            value=pick_field,
        )
        new_embed.set_field_at(
            3,
            name="Status",
            value=status_field,
        )
        await message.edit(embed=new_embed) 
    else:
        print("NO MESSAGE TO UPDATE???")

def get_next_movie(guild_id):
    """returns the movie picked by the last to pick"""
    user_id,picked_movie = database.get_last_active_picker(guild_id)

def set_picked_movie(user,movie):
    user_id = str(user.id)
    guild_id = str(user.guild.id)
    return database.set_user_picked_movie(user_id,guild_id,movie)


###COMMANDS###
# Send a list of movies to choose from but if it's not the first result will probably break since i'm not storing a movie ID, just the plain text name
@bot.slash_command()
@session_check()
async def pick_movie(ctx, *, movie_name):
    movies = get_movie_details(movie_name)
    
    if movies:
        movie = movies[0] 
        embed = discord.Embed(
            title=movie['title'],
            description=movie['overview'],
            color=discord.Color.green()
        )
        embed.add_field(name="Release Date", value=movie['release_date'], inline=True)
        embed.add_field(name="Rating", value=movie['vote_average'], inline=True)
        
        if movie['poster_path']:
            poster_url = f"https://image.tmdb.org/t/p/w500{movie['poster_path']}"
            embed.set_image(url=poster_url)
        await ctx.respond(embed=embed, view=MovieView(movies, ctx.author), ephemeral=True)
    else:
        await ctx.respond("Movie not found. Please try again.", ephemeral=True)
@bot.slash_command()
@session_check()
async def join_movienight(ctx):
    guild_id = str(ctx.guild.id)  # Get the current server (guild) ID
    user = ctx.author.id
    database.add_new_picker(user, guild_id)
    #TODO add message for failed to add
    await ctx.respond(f"Added new picker {user} to server {ctx.guild.name}")

@bot.slash_command()
@session_check()
async def i_hate_my_friends(ctx):
    guild_id = str(ctx.guild.id)  # Get the current server (guild) ID - Convert to string
    user = str(ctx.author.id)
    database.update_user_status(user,guild_id,"false")
    await ctx.respond(f"Set {ctx.authoer} pick status to false. IF THIS ISNT YOU SOMETHING FUCKED UP")

    ###This function will set you to inactive
    pass
@bot.slash_command()
@session_check()
async def i_like_my_friends(ctx):
    ###This function will set you to active
    guild_id = str(ctx.guild.id) 
    user = str(ctx.author.id)
    database.update_user_status(user,guild_id,"true")
    await ctx.respond(f"Set {ctx.authoer} pick status to true. IF THIS ISNT YOU SOMETHING FUCKED UP")

    pass

@bot.slash_command()    
@session_check()
async def lock_it_in(ctx):
    ###This is to set lock in the current movie - Only reason function is so you /watched to commit it and reveal the movie
    pass
@bot.slash_command()
@session_check()
async def watched(ctx):
    ### Commits the locked in movie to watched
    pass

########################TO REMOVE COMMANDS- FOR DEBUGGING################
@bot.slash_command()
async def test_command(ctx,*,username):
    print(username)
    if database.check_user_exists(username, str(ctx.guild.id)):
        await ctx.respond("USER EXISTS")
    else:
        await ctx.respond("DOES NOT EXIST")

@bot.slash_command()
@session_check()
async def manual_add_movie(ctx, movie_name,date_watched,picked_by_user):
    guild_id = str(ctx.guild.id)
    user_id = str()

bot.run(TOKEN)

############### EXTRA CLASSES - TODO: MOVE OUT OF HERE

# View class, multiple pages
class MovieView(View):
    def __init__(self, movies, user):
        super().__init__(timeout=60) 
        self.movies = movies
        self.index = 0  
        self.user = user 

    async def update_embed(self, interaction):
        """Update the embed with the current movie details."""
        movie = self.movies[self.index]
        embed = discord.Embed(
            title=movie['title'],
            description=movie['overview'],
            color=discord.Color.blue()
        )
        embed.add_field(name="Release Date", value=movie['release_date'], inline=True)
        embed.add_field(name="Rating", value=movie['vote_average'], inline=True)
        
        if movie['poster_path']:
            poster_url = f"https://image.tmdb.org/t/p/w500{movie['poster_path']}"
            embed.set_image(url=poster_url)

        await interaction.response.edit_message(embed=embed, view=self)

    @discord.ui.button(label="Previous", style=discord.ButtonStyle.secondary)
    async def previous_movie(self, button: Button, interaction: discord.Interaction):
        """Go to the previous movie."""
        if interaction.user == self.user:
            self.index = (self.index - 1) % len(self.movies)  # % to ensure wrap around
            await self.update_embed(interaction)


    @discord.ui.button(label="Next", style=discord.ButtonStyle.primary)
    async def next_movie(self, button: Button, interaction: discord.Interaction):
        """Go to the next movie."""
        if interaction.user == self.user:
            self.index = (self.index + 1) % len(self.movies)  
            await self.update_embed(interaction)


    @discord.ui.button(label="Pick", style=discord.ButtonStyle.success)
    async def register_movie(self, button: Button, interaction: discord.Interaction):
        """Picks the current movie."""
        if interaction.user == self.user:
            movie = self.movies[self.index]
            if set_picked_movie(interaction.user,movie['title']):
                await update_message(str(interaction.user.guild.id))
                await interaction.response.send_message(f"Selected '{movie['title']}' ", ephemeral=True)
            else:
                await interaction.response.send_message(f"Failed to select '{movie['title']}, #TODO - Add error codes' ", ephemeral=True)

class ConfirmManualAdd(View):
    def __init__(self, movie_name, user_id, date_watched, guild_id):
        super().__init__(timeout=60)  # Do I need a timeout? 
        self.movie_name = movie_name
        self.user_id = user_id
        self.date_watched = date_watched
        self.guild_id = guild_id

    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.success)
    async def confirm_button(self, button: Button, interaction: discord.Interaction):
        if database.check_if_watched(self.movie_name,self.guild_id):
            await interaction.response.send_message(f"We already watching this")
        else:
            database.add_watched_movie(self.movie_name, self.user_id, self.date_watched, self.guild_id)
            await interaction.response.send_message(f"Movie '{self.movie_name}' added successfully!", ephemeral=True)
            self.stop() 

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.danger)
    async def cancel_button(self, button: Button, interaction: discord.Interaction):
        await interaction.response.send_message("Movie addition canceled.", ephemeral=True)
        self.stop()  